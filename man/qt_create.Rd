% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qt_create.R
\name{qt_create}
\alias{qt_create}
\title{Create a quadtree from gridded data}
\usage{
qt_create(
  x,
  split_threshold = NULL,
  split_method = "range",
  combine_method = "mean",
  split_fun = NULL,
  split_args = list(),
  combine_fun = NULL,
  combine_args = list(),
  max_cell_length = NULL,
  adj_type = "expand",
  resample_n_side = NULL,
  extent = NULL,
  proj4string = NULL
)
}
\arguments{
\item{x}{a \code{raster} or a \code{matrix}. If \code{x} is a \code{matrix},
the \code{extent} and \code{proj4string} parameters can be used to set the
extent and projection of the quadtree. If \code{x} is a \code{raster}, the
extent and projection are derived from the raster.}

\item{split_threshold}{numeric; the threshold value used by the split method
(specified by \code{split_method}) to decided whether or not to split a
cell. If the value for a quadrant is greater than this value, the cell is split.
If \code{split_method} is "custom", this parameter is ignored.}

\item{split_method}{character; one of \code{"range"}, \code{"sd"} (standard
deviation), or \code{"custom"}. Determines the method used for calculating
the value used to determine whether or not to split a cell (this calculated
value is compared with \code{split_threshold} to decide whether to split a
cell). See 'Details' for more.}

\item{combine_method}{character; one of \code{"mean"}, \code{"median"},
\code{"min"}, \code{"max"}, or \code{"custom"}. Determines the method used
for aggregating the values of multiple cells into a single value for a
larger, aggregated cell}

\item{split_fun}{function; function used on each quadrant to decide whether
or not to split the cell. Only used when \code{split_method} is "custom".
Must take two arguments, \code{"vals"} (a numeric vector) and \code{"args"}
(a named list of arguments used within the function), and must output
\code{TRUE} if the quadrant is to be split and \code{FALSE} otherwise.}

\item{split_args}{list; named list that contains the arguments needed by
\code{split_fun}. This list is given to the \code{args} parameter of
\code{split_fun}}

\item{combine_fun}{function; function used to calculate the value of a
quadrant that consists of multiple cells. Only used when
\code{combine_method} is "custom"}

\item{combine_args}{list; named list that contains the arguments needed by
\code{combine_fun}. This list is given to the \code{args} parameter of
\code{combine_fun}}

\item{max_cell_length}{double; the maximum size allowed for a quadtree cell.
If \code{NULL} no restrictions are placed on the quadtree cell size. See
'Details' for more}

\item{adj_type}{character; either \code{'expand'} or \code{'resample'}. See
'Details' for more.}

\item{resample_n_side}{integer; if \code{adj_type} is \code{'expand'}, this
number is used to determine the dimensions to resample the raster to}

\item{extent}{\code{Extent} object or else a four-element numeric vector
describing the extent of the data (in this order: xmin, xmax, ymin, ymax).
Only used when \code{x} is a matrix - this parameter is ignored if \code{x}
is a raster. If no value is provided and \code{x} is a matrix, the extent
is assumed to be \code{c(0,ncol(x),0,nrow(x))}.}

\item{proj4string}{character; proj4string describing the projection of the
data. Only used when \code{x} is a matrix - this parameter is ignored if
\code{x} is a raster. If no value is provided and \code{x} is a matrix, the
'proj4string' of the quadtree is set to \code{NA}.}
}
\description{
Create a quadtree from gridded data
}
\details{
A quadtree is created from a raster by successively dividing the
  raster/matrix into smaller and smaller cells, with the decision on whether
  to divide a cell determined by a function that checks the cell values
  within each quadrant and returns \code{TRUE} if it should be split, and
  \code{FALSE} otherwise. Initially, all of the cells in the raster are
  considered. If the cell values meet the condition determined by the
  splitting function, the raster is divided into four quadrants - otherwise,
  the raster is not divided further and the value of this larger cell is
  calculated by applying a 'combine function' that aggregates the cell values
  into a single value (for example, mean and median). Then, the process is
  repeated for each of those 'child' cells, and then for their children, and
  so on and so forth, until either the split function returns \code{FALSE} or
  the smallest possible cell size has been reached.

  If a quadrant contains both NA cells and non-NA cells, that quadrant is
  automatically divided. However, if a quadrant consists entirely of NA
  cells, that cell is not divided further (even if the cell is larger than
  \code{max_cell_length}).

  If \code{max_cell_length} is not \code{NULL}, then the maximum cell size in
  the resulting quadtree will be \code{max_cell_length}. This essentially
  forces any quadrants larger than \code{max_cell_length} to split. The one
  exception is that a quadrant that contains entirely \code{NA} values will
  not be split.

  If a given quadrant has dimensions that are not divisible by 2 (for
  example, 5x5), then the process stops. Because of this, only rasters that
  have dimensions that are a power of 2 can be divided down to their smallest
  cell size. In addition, the rasters should be square. To create quadtrees
  from rasters that have dimensions that are not a power of two and are not
  square, two options are provided. The choice of method is determined by the
  \code{adj_type} parameter.

  In the 'expand' method, NA cells are added to the raster in order to create
  an expanded raster whose dimensions are a power of 2. The smallest number
  that is a power of two but greater than the larger dimension is used as the
  dimensions of the expanded raster. For example, if a raster has dimensions
  546 x 978, NA cells are added to the top and right of the raster in order
  to create a raster with dimensions 1024 x 1024 (as 1024 is the smallest
  power of 2 that is also greater than 978).

  In the 'resample' method, the raster is resampled in order to create a
  square matrix with dimensions that are a power of two. There are two steps.
  First, the raster must be made square. This is done in a way similar to the
  method described above. The smaller dimension is padded with NA cells in
  order to equal the larger dimension. For example, if the raster has
  dimensions 546 x 978, NA rows are added in order to create a raster with
  dimensions 978 x 978. In the second step, this raster is then resampled to
  a user-specified dimension (determined by the \code{resample_n_side}
  parameter). For example, the user could set \code{resample_n_side} to be
  1024, which will resample the 978 x 978 raster to 1024 x 1024. This raster
  can then be used to create a quadtree. The dimensions should be a power of 
  2 (see above for an explanation), although other numbers will be accepted 
  (but will trigger a warning).
  
  The method used to determine whether or not to split a cell as well as the
  method used to aggregate cell values can be defined by the user. Simple
  methods are already provided, but custom functions can be defined. For
  splitting a cell, two methods are provided. "range" checks the difference
  between the minimum value and the maximum value within the quadrant - if
  this difference exceeds \code{split_threshold}, the quadrant is split. "sd"
  uses the standard deviation of the cell values within a quadrant - if the
  standard deviation exceeds \code{split_threshold}, the quadrant is split.
  
  Four methods to aggregate cell values are provided - "mean", "median",
  "min", and "max" - the names are self-explanatory.
  
  Custom functions can be written to apply more complex rules to splitting
  and combining. These functions \emph{must} take two parameters: \code{vals}
  and \code{args}. \code{vals} is a numeric vector of the values of the cells
  within the current quadrant. \code{args} is a named list that contains the
  arguments need by the custom function. Any parameters needed for the
  function should be accessed through \code{args}. Note that even if no extra
  parameters are needed, the custom function still needs to take an
  \code{args} parameter. In this case it just won't be used by the function.

  \code{split_fun} must return a boolean, where \code{TRUE} indicates that
  the quadrant should be split. \code{combine_fun} must return a single
  numeric value.

  For example, a simple splitting function that splits a quadrant when the
  variance exceeds a certain limit could be defined as follows:

  \code{splt_fun = function(vals, args) return(var(vals) > args$var_limit)}

  Because the function makes use of an element of \code{args} named
  \code{var_limit}, the \code{split_args} parameter would need to contain an
  element called \code{var_limit}. For example:

  \code{qt = qt_create(rast, split_method="custom", split_fun=splt_fun,
  split_args=list(var_limit=.05))}
  
  Note that the provided splitting and combining functions are written in
  C++. So while we could define an R function to perform splitting based on
  the range, the C++ version will run much faster. Custom R functions will
  run slower than the provided C++ functions.
}
\examples{
library(raster)

#create raster of random values
nrow = 57
ncol = 75
rast = raster(matrix(runif(nrow*ncol), nrow=nrow, ncol=ncol), xmn=0, xmx=ncol, ymn=0, ymx=nrow)

#####################################
# using 'adj_type'
#####################################

#create quadtree using the 'expand' method - automatically adds NA cells to
#bring the dimensions to 128 x 128 before creating the quadtree
qt1 = qt_create(rast, split_threshold = .9, split_method = "range", adj_type="expand")
qt_plot(qt1) #plot the quadtree
qt_plot(qt1, crop=TRUE, na_col=NULL) #we can use 'crop=TRUE' and 'na_col=NULL' 
#if we don't want to see the padded NA's

#create quadtree using the 'resample' method - we'll resample to 128 since it's a power of 2
qt2 = qt_create(rast, split_threshold = .9, split_method = "range", adj_type="resample", resample_n_side = 128)
qt_plot(qt2)
qt_plot(qt2, crop=TRUE, na_col=NULL)

#####################################
# using 'max_cell_length'
#####################################

#now use the 'max_cell_length' argument to force any cells with sides longer
#than 2 to split
qt3 = qt_create(rast, split_threshold = .9, split_method = "range", max_cell_length = 2, adj_type="expand")

#compare qt1 (no max cell length) and qt3 (max cell length = 2)
par(mfrow=c(1,2))
qt_plot(qt1, crop=TRUE, na_col=NULL, main="no max cell length")
qt_plot(qt3, crop=TRUE, na_col=NULL, main="max cell length = 2")

#####################################
# using 'split_method' and 'combine_method'
#####################################

#use the standard deviation instead of the range
qt4 = qt_create(rast, split_threshold=.25, split_method = "sd")
#use the max to aggregate values rather than the mean
qt5 = qt_create(rast, split_threshold=.25, split_method = "sd", combine_method="max")

#compare the two quadtrees
par(mfrow=c(1,2))
qt_plot(qt4, crop=TRUE, na_col=NULL, main="split_method='sd', combine_method='mean'")
qt_plot(qt5, crop=TRUE, na_col=NULL, main="split_method='sd', combine_method='max'")
par(mfrow=c(1,1))

#####################################
# using custom split and combine methods
#####################################

#custom split function - split a cell if the values exceed a given range
spl_fun = function(vals, args){ 
  return(any(vals < args$min) || any(vals > args$max))
}

qt6 = qt_create(rast, split_method="custom", split_fun=spl_fun, 
                split_args=list(min=.02, max=.98))
qt_plot(qt6, crop=TRUE, na_col=NULL)

#custom combine function
cmb_fun = function(vals, args){
  if(any(is.na(vals))){
    return(NA)
  }
  if(any(vals < args$low)){
    return(args$low)
  } else if (any(vals > args$high)){
    return(args$high)   
  } else {
    return((args$low + args$high)/2)
  }
}

qt7 = qt_create(rast, split_threshold = .9, split_method="range", combine_method="custom",
                combine_fun = cmb_fun, combine_args = list(low=.2, high=.8))
qt_plot(qt7, crop=TRUE, na_col=NULL)

#note that the split and combine functions are required to have an 'args'
#parameter, but they don't have to use it
cmb_fun2 = function(vals, args){
  return(max(vals) - min(vals))
}

qt8 = qt_create(rast, split_threshold = .9, split_method = "range", 
                combine_fun = cmb_fun2)
qt_plot(qt8, crop=TRUE, na_col=NULL)
}
